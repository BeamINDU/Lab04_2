import re
from typing import Dict, Any, List, Set
import logging

logger = logging.getLogger(__name__)

class IntentClassifier:
    """üéØ Intent Classifier - Main interface class"""
    
    def __init__(self):
        self.smart_classifier = SmartIntentClassifier()
        logger.info("‚úÖ IntentClassifier initialized")
    
    def classify_intent(self, question: str) -> Dict[str, Any]:
        """Main method to classify user intent"""
        return self.smart_classifier.classify_intent(question)
    
    def get_debug_analysis(self, question: str) -> Dict[str, Any]:
        """Get detailed analysis for debugging"""
        return self.smart_classifier.get_debug_analysis(question)

class SmartIntentClassifier:
    """üß† Smart Intent Classifier ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ patterns ‡πÅ‡∏ö‡∏ö dynamic"""
    
    def __init__(self):
        # üéØ Core business entities (‡πÅ‡∏ó‡∏ô hard code patterns)
        self.business_entities = self._load_business_entities()
        self.question_structures = self._load_question_structures()
        self.context_indicators = self._load_context_indicators()
        
        # üìä Dynamic scoring weights
        self.scoring_weights = {
            'business_entity_score': 0.4,
            'question_structure_score': 0.3,
            'context_score': 0.2,
            'verb_action_score': 0.1
        }
        
        logger.info("‚úÖ Smart Intent Classifier initialized with dynamic learning")
    
    def _load_business_entities(self) -> Dict[str, List[str]]:
        """üè¢ Core business entities ‡πÅ‡∏ó‡∏ô hard code patterns"""
        return {
            'people': [
                '‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô', 'employee', 'staff', '‡∏Ñ‡∏ô', 'people', '‡πÉ‡∏Ñ‡∏£', 'who',
                '‡∏ô‡∏±‡∏Å‡∏û‡∏±‡∏í‡∏ô‡∏≤', 'developer', '‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÄ‡∏°‡∏≠‡∏£‡πå', 'programmer',
                '‡∏ó‡∏µ‡∏°', 'team', '‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å', 'member'
            ],
            'work_items': [
                '‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ', 'project', '‡∏á‡∏≤‡∏ô', 'work', 'task', '‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥',
                '‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à', 'responsibility', '‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà', 'duty'
            ],
            'organizational': [
                '‡πÅ‡∏ú‡∏ô‡∏Å', 'department', '‡∏ù‡πà‡∏≤‡∏¢', 'division', '‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á', 'position',
                '‡∏ö‡∏£‡∏¥‡∏©‡∏±‡∏ó', 'company', '‡∏≠‡∏á‡∏Ñ‡πå‡∏Å‡∏£', 'organization'
            ],
            'technical_roles': [
                'frontend', 'backend', 'fullstack', 'devops', 'senior', 'junior',
                'lead', 'architect', 'designer', 'tester', 'analyst'
            ],
            'data_metrics': [
                '‡∏Å‡∏µ‡πà‡∏Ñ‡∏ô', '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô', '‡∏£‡∏≤‡∏Ñ‡∏≤', '‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', '‡∏á‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì', 'budget',
                'cost', 'salary', 'count', 'total', 'sum'
            ]
        }
    
    def _load_question_structures(self) -> Dict[str, List[str]]:
        """‚ùì Question structure patterns"""
        return {
            'who_questions': ['‡πÉ‡∏Ñ‡∏£', 'who', '‡∏Ñ‡∏ô‡πÑ‡∏´‡∏ô', '‡πÉ‡∏Ñ‡∏£‡∏ö‡πâ‡∏≤‡∏á'],
            'what_questions': ['‡∏≠‡∏∞‡πÑ‡∏£', 'what', '‡∏™‡∏¥‡πà‡∏á‡πÑ‡∏´‡∏ô', '‡∏≠‡∏∞‡πÑ‡∏£‡∏ö‡πâ‡∏≤‡∏á'],
            'how_many_questions': ['‡∏Å‡∏µ‡πà', 'how many', '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô', '‡∏°‡∏µ‡∏Å‡∏µ‡πà'],
            'where_questions': ['‡∏ó‡∏µ‡πà‡πÑ‡∏´‡∏ô', 'where', '‡∏ï‡∏£‡∏á‡πÑ‡∏´‡∏ô'],
            'when_questions': ['‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏£', 'when', '‡πÄ‡∏ß‡∏•‡∏≤‡πÑ‡∏´‡∏ô'],
            'analysis_questions': ['‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå', 'analyze', '‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö', 'compare']
        }
    
    def _load_context_indicators(self) -> Dict[str, List[str]]:
        """üéØ Context indicators"""
        return {
            'business_context': [
                '‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô', 'report', '‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥', 'statistics', '‡∏ú‡∏•‡∏á‡∏≤‡∏ô', 'performance',
                '‡∏Å‡∏≥‡πÑ‡∏£', 'profit', '‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô', 'loss', '‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå', 'percentage'
            ],
            'conversational_context': [
                '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ', 'hello', 'hi', '‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì', 'thank you', 'thanks',
                '‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô', 'bye', 'goodbye', '‡∏™‡∏ö‡∏≤‡∏¢‡∏î‡∏µ', 'how are you'
            ],
            'system_context': [
                '‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠‡πÉ‡∏Ñ‡∏£', 'who are you', '‡∏ä‡πà‡∏ß‡∏¢‡∏≠‡∏∞‡πÑ‡∏£', 'what can you do',
                '‡∏£‡∏∞‡∏ö‡∏ö', 'system', '‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°', 'program'
            ]
        }
    
    def classify_intent(self, question: str) -> Dict[str, Any]:
        """üéØ Main classification method with dynamic scoring"""
        
        question_lower = question.strip().lower()
        
        # üí¨ Quick check for pure conversational
        if self._is_pure_conversational(question_lower):
            return {
                'intent': 'conversational',
                'should_use_sql': False,
                'confidence': 0.95,
                'reasoning': 'Pure conversational greeting/polite expression',
                'classification_method': 'pattern_based_conversational'
            }
        
        # üìä Calculate dynamic scores
        scores = self._calculate_dynamic_scores(question_lower)
        total_business_score = sum(scores.values())
        
        # üéØ Smart decision making
        if total_business_score >= 0.6:
            intent = 'business_query'
            should_use_sql = True
            confidence = min(0.95, 0.6 + (total_business_score - 0.6) * 0.5)
            reasoning = f"High business content (score: {total_business_score:.2f})"
        elif total_business_score >= 0.3:
            # ü§ñ Mixed content - check context
            mixed_analysis = self._analyze_mixed_content(question_lower)
            if mixed_analysis['business_dominant']:
                intent = 'business_query'
                should_use_sql = True
                confidence = 0.75
                reasoning = f"Mixed content but business dominant (score: {total_business_score:.2f})"
            else:
                intent = 'conversational'
                should_use_sql = False
                confidence = 0.65
                reasoning = f"Mixed content but conversational dominant (score: {total_business_score:.2f})"
        else:
            intent = 'conversational'
            should_use_sql = False
            confidence = 0.85
            reasoning = f"Low business content (score: {total_business_score:.2f})"
        
        return {
            'intent': intent,
            'should_use_sql': should_use_sql,
            'confidence': confidence,
            'reasoning': reasoning,
            'business_score': total_business_score,
            'detailed_scores': scores,
            'classification_method': 'dynamic_scoring'
        }
    
    def _is_pure_conversational(self, question_lower: str) -> bool:
        """üí¨ Check for pure conversational patterns"""
        
        pure_conversational_patterns = [
            # Thai greetings
            r'^‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ(‡∏Ñ‡∏£‡∏±‡∏ö|‡∏Ñ‡πà‡∏∞|‡∏Ñ‡∏∞)*$',
            r'^‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ\s+(‡∏Ñ‡∏£‡∏±‡∏ö|‡∏Ñ‡πà‡∏∞|‡∏Ñ‡∏∞)$',
            r'^‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì(‡∏Ñ‡∏£‡∏±‡∏ö|‡∏Ñ‡πà‡∏∞|‡∏Ñ‡∏∞|‡∏°‡∏≤‡∏Å)*$',
            r'^‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô(‡∏Ñ‡∏£‡∏±‡∏ö|‡∏Ñ‡πà‡∏∞|‡∏Ñ‡∏∞)*$',
            
            # English greetings
            r'^hi+$', r'^hello+$', r'^hey+$',
            r'^thank\s*you$', r'^thanks$', r'^bye$', r'^goodbye$',
            
            # System questions
            r'^‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠‡πÉ‡∏Ñ‡∏£$', r'^who\s+are\s+you$',
            r'^‡∏Ñ‡∏∏‡∏ì‡∏ä‡πà‡∏ß‡∏¢‡∏≠‡∏∞‡πÑ‡∏£‡πÑ‡∏î‡πâ‡∏ö‡πâ‡∏≤‡∏á$', r'^what\s+can\s+you\s+do$'
        ]
        
        for pattern in pure_conversational_patterns:
            if re.match(pattern, question_lower, re.IGNORECASE):
                return True
        
        return False
    
    def _calculate_dynamic_scores(self, question_lower: str) -> Dict[str, float]:
        """üìä Calculate dynamic scores for different aspects"""
        
        scores = {}
        
        # 1. Business Entity Score
        business_entity_matches = 0
        total_business_entities = 0
        for category, entities in self.business_entities.items():
            total_business_entities += len(entities)
            for entity in entities:
                if entity.lower() in question_lower:
                    business_entity_matches += 1
        
        scores['business_entity_score'] = (business_entity_matches / max(total_business_entities, 1)) * self.scoring_weights['business_entity_score']
        
        # 2. Question Structure Score
        question_structure_matches = 0
        total_structures = 0
        for category, structures in self.question_structures.items():
            total_structures += len(structures)
            for structure in structures:
                if structure.lower() in question_lower:
                    question_structure_matches += 1
        
        scores['question_structure_score'] = (question_structure_matches / max(total_structures, 1)) * self.scoring_weights['question_structure_score']
        
        # 3. Context Score
        business_context_matches = 0
        conversational_context_matches = 0
        
        for indicator in self.context_indicators['business_context']:
            if indicator.lower() in question_lower:
                business_context_matches += 1
        
        for indicator in self.context_indicators['conversational_context']:
            if indicator.lower() in question_lower:
                conversational_context_matches += 1
        
        # Context score favors business context
        context_score = max(0, business_context_matches - conversational_context_matches) * 0.1
        scores['context_score'] = min(context_score, self.scoring_weights['context_score'])
        
        # 4. Verb Action Score
        action_verbs = ['‡∏î‡∏π', 'show', '‡∏´‡∏≤', 'find', '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£', 'want', '‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå', 'analyze']
        verb_action_matches = sum(1 for verb in action_verbs if verb.lower() in question_lower)
        scores['verb_action_score'] = min(verb_action_matches * 0.05, self.scoring_weights['verb_action_score'])
        
        return scores
    
    def _analyze_mixed_content(self, question_lower: str) -> Dict[str, Any]:
        """ü§ñ Analyze mixed content to determine dominance"""
        
        business_indicators = 0
        conversational_indicators = 0
        
        # Count business vs conversational indicators
        for category, entities in self.business_entities.items():
            for entity in entities:
                if entity.lower() in question_lower:
                    business_indicators += 1
        
        for indicator in self.context_indicators['conversational_context']:
            if indicator.lower() in question_lower:
                conversational_indicators += 1
        
        return {
            'business_indicators': business_indicators,
            'conversational_indicators': conversational_indicators,
            'business_dominant': business_indicators > conversational_indicators,
            'analysis': f"Business: {business_indicators}, Conversational: {conversational_indicators}"
        }
    
    def get_debug_analysis(self, question: str) -> Dict[str, Any]:
        """üîç Get detailed analysis for debugging"""
        question_lower = question.strip().lower()
        
        scores = self._calculate_dynamic_scores(question_lower)
        total_score = sum(scores.values())
        
        # Find matching entities
        matching_entities = {}
        for category, entities in self.business_entities.items():
            matches = [entity for entity in entities if entity.lower() in question_lower]
            if matches:
                matching_entities[category] = matches
        
        return {
            'question': question,
            'question_lower': question_lower,
            'individual_scores': scores,
            'total_business_score': total_score,
            'matching_entities': matching_entities,
            'decision': 'business_query' if total_score >= 0.6 else ('moderate' if total_score >= 0.3 else 'conversation'),
            'is_pure_conversational': self._is_pure_conversational(question_lower)
        }

# üß™ Test the Smart Intent Classifier
def test_smart_intent_classifier():
    """üß™ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Smart Intent Classifier"""
    
    classifier = SmartIntentClassifier()
    
    test_cases = [
        # Should be business_query
        ("‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô siamtech ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô‡∏£‡∏±‡∏ö‡∏ú‡∏¥‡∏î‡∏ä‡∏≠‡∏ö‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏≠‡∏∞‡πÑ‡∏£‡∏ö‡πâ‡∏≤‡∏á", True),
        ("‡πÉ‡∏Ñ‡∏£‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏áfrontend‡∏ö‡πâ‡∏≤‡∏á", True),  # üéØ ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÄ‡∏î‡∏¥‡∏°
        ("‡∏°‡∏µ‡πÉ‡∏Ñ‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô backend ‡∏ö‡πâ‡∏≤‡∏á", True),
        ("‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô frontend ‡∏Ñ‡∏∑‡∏≠‡πÉ‡∏Ñ‡∏£", True),
        ("‡πÉ‡∏Ñ‡∏£‡πÄ‡∏õ‡πá‡∏ô senior developer", True),
        ("‡∏°‡∏µ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏≠‡∏∞‡πÑ‡∏£‡∏ö‡πâ‡∏≤‡∏á", True),
        ("‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡πÅ‡∏ú‡∏ô‡∏Å IT ‡∏Å‡∏µ‡πà‡∏Ñ‡∏ô", True),
        
        # Should be conversation
        ("‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡∏£‡∏±‡∏ö", False),
        ("‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏°‡∏≤‡∏Å‡∏Ñ‡∏£‡∏±‡∏ö", False),
        ("‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠‡πÉ‡∏Ñ‡∏£", False),
        ("hello", False),
        
        # Edge cases
        ("‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ ‡∏°‡∏µ frontend developer ‡∏Å‡∏µ‡πà‡∏Ñ‡∏ô", True),  # Mixed but business wins
    ]
    
    print("üß™ Testing Smart Intent Classifier")
    print("=" * 70)
    print("üéØ Focus: Fix '‡πÉ‡∏Ñ‡∏£‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏áfrontend‡∏ö‡πâ‡∏≤‡∏á' classification")
    print("=" * 70)
    
    correct = 0
    total = len(test_cases)
    
    for question, expected_sql in test_cases:
        result = classifier.classify_intent(question)
        actual_sql = result['should_use_sql']
        status = "‚úÖ" if actual_sql == expected_sql else "‚ùå"
        
        print(f"{status} {question}")
        print(f"   Expected: {expected_sql}, Got: {actual_sql}")
        print(f"   Confidence: {result['confidence']:.2f}")
        print(f"   Reasoning: {result['reasoning']}")
        
        if actual_sql == expected_sql:
            correct += 1
        
        # Show debug for failed cases
        if actual_sql != expected_sql:
            debug = classifier.get_debug_analysis(question)
            print(f"   üîç Scores: {debug['individual_scores']}")
            print(f"   üîç Total: {debug['total_business_score']:.2f}")
            print(f"   üîç Entities: {debug['matching_entities']}")
        
        print()
    
    accuracy = (correct / total) * 100
    print("=" * 70)
    print(f"üìä Results: {correct}/{total} correct ({accuracy:.1f}% accuracy)")
    
    if accuracy >= 90:
        print("üéâ EXCELLENT! Smart Intent Classifier is working!")
    elif accuracy >= 80:
        print("‚úÖ GOOD! Minor improvements needed")
    else:
        print("‚ö†Ô∏è NEEDS WORK! Significant fixes required")
    
    return accuracy >= 85

if __name__ == "__main__":
    test_smart_intent_classifier()
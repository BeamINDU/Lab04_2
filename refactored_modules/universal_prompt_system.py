# üéØ Complete Universal Prompt System - Multi-Tenant Ready
# refactored_modules/universal_prompt_system.py

import os
import json
import asyncio
from datetime import datetime
from typing import Dict, Any, Optional, List, Tuple, Set
from dataclasses import dataclass, asdict
import logging
from functools import lru_cache
import re

logger = logging.getLogger(__name__)

@dataclass
class CompanyProfile:
    """Profile ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ Company"""
    company_id: str
    name: str
    business_type: str
    language: str
    prompt_template: str
    sql_patterns: Dict[str, str]
    business_entities: List[str]
    currency: str = "THB"
    created_at: str = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now().isoformat()

class UniversalPromptGenerator:
    """üéØ Universal Prompt System ‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Multi-Tenant"""
    
    def __init__(self):
        # Initialize core components
        self.company_profiles = self._load_company_profiles()
        self.prompt_templates = self._load_prompt_templates()
        self.type_safety_rules = self._load_type_safety_rules()
        self.pattern_matchers = self._load_pattern_matchers()
        self.business_logic_mappings = self._load_business_logic_mappings()
        
        # Statistics
        self.generation_stats = {
            'total_queries': 0,
            'successful_generations': 0,
            'template_usage': {},
            'tenant_usage': {}
        }
        
        logger.info("‚úÖ Universal Prompt System initialized with complete multi-tenant support")
    
    def _load_company_profiles(self) -> Dict[str, CompanyProfile]:
        """‡πÇ‡∏´‡∏•‡∏î Company Profiles ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î"""
        profiles = {}
        
        # Company A - Bangkok HQ (Enterprise)
        profiles['company-a'] = CompanyProfile(
            company_id='company-a',
            name='SiamTech Bangkok HQ',
            business_type='enterprise_software',
            language='th',
            prompt_template='enterprise_thai',
            sql_patterns={
                'employee_analysis': 'complex_joins_with_aggregation',
                'project_analysis': 'budget_focus_with_teams',
                'department_analysis': 'hierarchy_aware'
            },
            business_entities=[
                '‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô', 'employee', '‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ', 'project', '‡πÅ‡∏ú‡∏ô‡∏Å', 'department',
                '‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', 'salary', '‡∏á‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì', 'budget', '‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£', 'banking'
            ],
            currency='THB'
        )
        
        # Company B - Chiang Mai Regional (Tourism)
        profiles['company-b'] = CompanyProfile(
            company_id='company-b',
            name='SiamTech Chiang Mai Regional',
            business_type='tourism_hospitality',
            language='th',
            prompt_template='tourism_thai',
            sql_patterns={
                'project_analysis': 'tourism_focused',
                'client_analysis': 'regional_hospitality',
                'employee_analysis': 'local_specialization'
            },
            business_entities=[
                '‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô', 'employee', '‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ', 'project', '‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß', 'tourism',
                '‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°', 'hotel', '‡∏£‡∏µ‡∏™‡∏≠‡∏£‡πå‡∏ó', 'resort', '‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤', 'client',
                '‡πÄ‡∏ä‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà', 'chiang mai', '‡∏†‡∏≤‡∏Ñ‡πÄ‡∏´‡∏ô‡∏∑‡∏≠', 'northern'
            ],
            currency='THB'
        )
        
        # Company C - International (Global)
        profiles['company-c'] = CompanyProfile(
            company_id='company-c',
            name='SiamTech International',
            business_type='global_operations',
            language='en',
            prompt_template='international_english',
            sql_patterns={
                'project_analysis': 'multi_currency_global',
                'client_analysis': 'international_markets',
                'financial_analysis': 'usd_focused'
            },
            business_entities=[
                'employee', 'employees', 'project', 'projects', 'international',
                'global', 'USD', 'dollar', 'overseas', 'multinational',
                'cross-border', 'foreign', 'worldwide'
            ],
            currency='USD'
        )
        
        return profiles
    
    def _load_prompt_templates(self) -> Dict[str, str]:
        """‡πÇ‡∏´‡∏•‡∏î Prompt Templates ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ò‡∏∏‡∏£‡∏Å‡∏¥‡∏à"""
        return {
            'enterprise_thai': """‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠ PostgreSQL Expert ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {company_name} (Enterprise Software)

üè¢ ‡∏ö‡∏£‡∏¥‡∏ö‡∏ó‡∏ò‡∏∏‡∏£‡∏Å‡∏¥‡∏à: ‡∏ö‡∏£‡∏¥‡∏©‡∏±‡∏ó‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏ã‡∏≠‡∏ü‡∏ï‡πå‡πÅ‡∏ß‡∏£‡πå‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà ‡πÄ‡∏ô‡πâ‡∏ô‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£‡πÅ‡∏•‡∏∞ E-commerce
üí∞ ‡∏™‡∏Å‡∏∏‡∏•‡πÄ‡∏á‡∏¥‡∏ô: ‡∏ö‡∏≤‡∏ó (THB)
üìä ‡πÄ‡∏ô‡πâ‡∏ô: Performance, Scalability, Complex Business Logic

üìã ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:
‚Ä¢ employees: id, name, department, position, salary, hire_date, email
‚Ä¢ projects: id, name, client, budget, status, start_date, end_date, tech_stack
‚Ä¢ employee_projects: employee_id, project_id, role, allocation

üéØ ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô SQL ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Enterprise:
1. ‡πÉ‡∏ä‡πâ explicit column names (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ SELECT *)
2. ‡πÉ‡∏ä‡πâ LEFT JOIN ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö assignment queries ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
3. ‡πÉ‡∏ä‡πâ COALESCE ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö NULL handling: '‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ', '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó'
4. ‡∏à‡∏±‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏á‡∏¥‡∏ô: TO_CHAR(amount, 'FM999,999,999') || ' ‡∏ö‡∏≤‡∏ó'
5. ‡πÉ‡∏ä‡πâ aggregate functions: COUNT, SUM, AVG, MAX, MIN
6. ‡πÉ‡∏™‡πà ORDER BY ‡πÅ‡∏•‡∏∞ LIMIT ‡πÄ‡∏™‡∏°‡∏≠
7. ‡πÉ‡∏ä‡πâ ILIKE ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö text search ‡πÉ‡∏ô PostgreSQL

‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°: {question}

‡∏™‡∏£‡πâ‡∏≤‡∏á PostgreSQL query:""",

            'tourism_thai': """‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠ PostgreSQL Expert ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {company_name} (Tourism & Hospitality)

üè® ‡∏ö‡∏£‡∏¥‡∏ö‡∏ó‡∏ò‡∏∏‡∏£‡∏Å‡∏¥‡∏à: ‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß‡πÅ‡∏•‡∏∞‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏° ‡∏™‡∏≤‡∏Ç‡∏≤‡∏†‡∏≤‡∏Ñ‡πÄ‡∏´‡∏ô‡∏∑‡∏≠
üí∞ ‡∏™‡∏Å‡∏∏‡∏•‡πÄ‡∏á‡∏¥‡∏ô: ‡∏ö‡∏≤‡∏ó (THB)
üìä ‡πÄ‡∏ô‡πâ‡∏ô: Regional Tourism, Hospitality Systems, Local Business

üìã ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:
‚Ä¢ employees: id, name, department, position, salary, hire_date, email
‚Ä¢ projects: id, name, client, budget, status, start_date, end_date, tech_stack
‚Ä¢ employee_projects: employee_id, project_id, role, allocation

üèîÔ∏è ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å: ‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°, TAT, ‡∏™‡∏ß‡∏ô‡∏û‡∏§‡∏Å‡∏©‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå, ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏≤‡∏´‡∏≤‡∏£, ‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢

üéØ ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô SQL ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Tourism:
1. ‡∏°‡∏≠‡∏á‡∏´‡∏≤ keywords: ‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß, ‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°, tourism, hotel
2. ‡πÄ‡∏ô‡πâ‡∏ô‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö hospitality industry
3. ‡πÉ‡∏ä‡πâ ILIKE ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤: '%‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°%', '%‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß%'
4. ‡∏á‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì‡∏°‡∏±‡∏Å‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á 300k-800k ‡∏ö‡∏≤‡∏ó
5. ‡πÉ‡∏ä‡πâ LEFT JOIN ‡πÅ‡∏•‡∏∞ COALESCE ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô enterprise
6. ‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° business priority

‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°: {question}

‡∏™‡∏£‡πâ‡∏≤‡∏á PostgreSQL query ‡∏ó‡∏µ‡πà‡πÄ‡∏ô‡πâ‡∏ô tourism business:""",

            'international_english': """You are a PostgreSQL Expert for {company_name} (Global Operations)

üåç Business Context: International software solutions, global clients
üí∞ Currency: USD (primary), multi-currency support
üìä Focus: Cross-border operations, International compliance, Global scale

üìã Database Schema:
‚Ä¢ employees: id, name, department, position, salary, hire_date, email
‚Ä¢ projects: id, name, client, budget, status, start_date, end_date, tech_stack
‚Ä¢ employee_projects: employee_id, project_id, role, allocation

üåê Key Clients: MegaCorp International, Global Finance Corp, Education Global Network

üéØ SQL Rules for International Business:
1. Look for keywords: international, global, USD, dollar, overseas
2. Budget often in USD range: $1M - $4M
3. Use LEFT JOIN and COALESCE for complete data: 'No Project', 'No Role'
4. Format currency: TO_CHAR(amount, 'FM999,999,999') || ' USD'
5. Search clients: ILIKE '%International%', '%Global%', '%Corp%'
6. Focus on high-value international projects
7. Order by business value and impact

Question: {question}

Generate PostgreSQL query for international business analysis:"""
        }
    
    def _load_type_safety_rules(self) -> Dict[str, Any]:
        """‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏é Type Safety ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô SQL errors"""
        return {
            'date_fields': ['hire_date', 'start_date', 'end_date', 'created_at'],
            'numeric_fields': ['salary', 'budget', 'allocation', 'id'],
            'text_fields': ['name', 'department', 'position', 'client', 'email'],
            'enum_fields': {
                'status': ['active', 'completed', 'cancelled'],
                'department': ['IT', 'Sales', 'Management', 'HR']
            },
            'null_substitutes': {
                'project_name': '‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ',
                'project_role': '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó',
                'client': '-',
                'allocation': '0%'
            },
            'safe_patterns': [
                r'COALESCE\([^,]+,\s*\'[^\']+\'\)',  # Safe COALESCE usage
                r'TO_CHAR\([^,]+,\s*\'[^\']+\'\)',   # Safe formatting
                r'ILIKE\s*\'%[^%]*%\'',              # Safe ILIKE patterns
            ],
            'dangerous_patterns': [
                r'WHERE.*=.*\'‡πÑ‡∏°‡πà‡∏°‡∏µ\'',               # Direct comparison with Thai text
                r'DATE\(\'[^\']*‡πÑ‡∏°‡πà‡∏°‡∏µ[^\']*\'\)',      # Invalid date casting
                r'CAST\([^)]*‡πÑ‡∏°‡πà‡∏°‡∏µ[^)]*\sAS\s',       # Invalid casting
            ]
        }
    
    def _load_pattern_matchers(self) -> Dict[str, List[str]]:
        """‡πÇ‡∏´‡∏•‡∏î Pattern Matchers ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°"""
        return {
            'assignment_queries': [
                r'(‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô.*(?:‡∏£‡∏±‡∏ö‡∏ú‡∏¥‡∏î‡∏ä‡∏≠‡∏ö|‡∏ó‡∏≥‡∏á‡∏≤‡∏ô|‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£))',
                r'(each.*(?:responsible|work|manage))',
                r'(‡∏£‡∏±‡∏ö‡∏ú‡∏¥‡∏î‡∏ä‡∏≠‡∏ö.*(?:‡∏≠‡∏∞‡πÑ‡∏£|‡πÑ‡∏´‡∏ô|‡∏ö‡πâ‡∏≤‡∏á))',
                r'(assignment|assigned|allocate)'
            ],
            'project_queries': [
                r'(‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ.*(?:‡∏≠‡∏∞‡πÑ‡∏£|‡πÑ‡∏´‡∏ô|‡∏ö‡πâ‡∏≤‡∏á|‡∏°‡∏µ|‡∏Å‡∏µ‡πà))',
                r'(project.*(?:what|which|list|how many))',
                r'(‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß.*(?:‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ|‡∏á‡∏≤‡∏ô))',  # Tourism specific
                r'(USD.*(?:budget|project))',        # International specific
            ],
            'employee_queries': [
                r'(‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô.*(?:‡∏Ñ‡∏ô|‡πÉ‡∏Ñ‡∏£|‡πÑ‡∏´‡∏ô|‡∏Å‡∏µ‡πà))',
                r'(employee.*(?:who|how many|work))',
                r'(‡∏Å‡∏µ‡πà‡∏Ñ‡∏ô.*(?:‡πÅ‡∏ú‡∏ô‡∏Å|department))'
            ],
            'financial_queries': [
                r'(‡∏á‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì.*(?:‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î|‡∏°‡∏≤‡∏Å|‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà))',
                r'(budget.*(?:highest|maximum|USD))',
                r'(‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô.*(?:‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î|‡∏°‡∏≤‡∏Å))',
                r'(salary.*(?:highest|maximum))'
            ]
        }
    
    def _load_business_logic_mappings(self) -> Dict[str, Dict[str, str]]:
        """‡πÇ‡∏´‡∏•‡∏î Business Logic Mappings ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ tenant"""
        return {
            'company-a': {
                'high_budget': 'budget > 2000000',
                'senior_employee': "position ILIKE '%senior%' OR position ILIKE '%lead%' OR position ILIKE '%manager%'",
                'recent_project': "start_date > CURRENT_DATE - INTERVAL '1 year'",
                'active_project': "status = 'active'"
            },
            'company-b': {
                'tourism_project': "client ILIKE '%‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß%' OR client ILIKE '%‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°%' OR client ILIKE '%tourism%' OR client ILIKE '%hotel%'",
                'regional_client': "client ILIKE '%‡πÄ‡∏ä‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà%' OR client ILIKE '%‡∏†‡∏≤‡∏Ñ‡πÄ‡∏´‡∏ô‡∏∑‡∏≠%'",
                'medium_budget': 'budget BETWEEN 300000 AND 800000',
                'hospitality_focus': "client ILIKE '%‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°%' OR client ILIKE '%‡∏£‡∏µ‡∏™‡∏≠‡∏£‡πå‡∏ó%'"
            },
            'company-c': {
                'international_project': "client ILIKE '%International%' OR client ILIKE '%Global%'",
                'high_value_usd': 'budget > 2000000',  # Assuming USD amounts
                'global_client': "client ILIKE '%Corp%' OR client ILIKE '%International%' OR client ILIKE '%Global%'",
                'enterprise_scale': 'budget > 1500000'
            }
        }
    
    async def generate_sql_with_universal_prompt(self, question: str, tenant_id: str, agent=None) -> Tuple[str, Dict[str, Any]]:
        """üéØ ‡∏´‡∏•‡∏±‡∏Å method ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö SQL generation ‡∏î‡πâ‡∏ß‡∏¢ Universal Prompt"""
        
        start_time = datetime.now()
        
        # Update statistics
        self.generation_stats['total_queries'] += 1
        if tenant_id not in self.generation_stats['tenant_usage']:
            self.generation_stats['tenant_usage'][tenant_id] = 0
        self.generation_stats['tenant_usage'][tenant_id] += 1
        
        try:
            # 1. Get company profile
            if tenant_id not in self.company_profiles:
                raise ValueError(f"Unknown tenant: {tenant_id}")
            
            profile = self.company_profiles[tenant_id]
            
            # 2. Analyze question type
            question_type = self._analyze_question_type(question, profile)
            
            # 3. Generate context-aware prompt
            prompt = self._generate_context_aware_prompt(question, profile, question_type)
            
            # 4. Call AI with universal prompt
            if agent and hasattr(agent, 'ai_service'):
                config = agent.tenant_configs[tenant_id]
                ai_response = await agent.ai_service.call_ollama_api(
                    tenant_config=config,
                    prompt=prompt,
                    context_data="",
                    temperature=0.1  # Low temperature for accurate SQL
                )
            else:
                raise ValueError("Agent or AI service not available")
            
            # 5. Extract and validate SQL
            sql_query = self._extract_and_validate_sql(ai_response, profile, question_type)
            
            # 6. Apply type safety rules
            safe_sql = self._apply_type_safety_rules(sql_query, profile)
            
            processing_time = (datetime.now() - start_time).total_seconds()
            
            # 7. Create metadata
            metadata = {
                'method': 'universal_prompt_system',
                'template_used': profile.prompt_template,
                'question_type': question_type,
                'business_type': profile.business_type,
                'confidence': self._calculate_confidence(safe_sql, question, profile),
                'processing_time': processing_time,
                'tenant_id': tenant_id,
                'language': profile.language,
                'currency': profile.currency
            }
            
            # Update template usage stats
            template = profile.prompt_template
            if template not in self.generation_stats['template_usage']:
                self.generation_stats['template_usage'][template] = 0
            self.generation_stats['template_usage'][template] += 1
            
            self.generation_stats['successful_generations'] += 1
            
            logger.info(f"‚úÖ Universal Prompt success for {tenant_id}: {question_type} query")
            
            return safe_sql, metadata
            
        except Exception as e:
            logger.error(f"‚ùå Universal Prompt failed for {tenant_id}: {e}")
            
            # Fallback metadata
            metadata = {
                'method': 'universal_prompt_fallback',
                'error': str(e),
                'confidence': 'low',
                'tenant_id': tenant_id
            }
            
            # Generate safe fallback SQL
            fallback_sql = self._generate_safe_fallback_sql(question, tenant_id)
            
            return fallback_sql, metadata
    
    def _analyze_question_type(self, question: str, profile: CompanyProfile) -> str:
        """üîç ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°"""
        question_lower = question.lower()
        
        # Check against pattern matchers
        for question_type, patterns in self.pattern_matchers.items():
            for pattern in patterns:
                if re.search(pattern, question_lower, re.IGNORECASE):
                    return question_type.replace('_queries', '')
        
        # Business-specific detection
        if profile.business_type == 'tourism_hospitality':
            tourism_keywords = ['‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß', 'tourism', '‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°', 'hotel']
            if any(keyword in question_lower for keyword in tourism_keywords):
                return 'tourism_project'
        
        elif profile.business_type == 'global_operations':
            international_keywords = ['usd', 'international', 'global', 'dollar']
            if any(keyword in question_lower for keyword in international_keywords):
                return 'international_project'
        
        # Default analysis
        if any(word in question_lower for word in ['‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô', '‡∏£‡∏±‡∏ö‡∏ú‡∏¥‡∏î‡∏ä‡∏≠‡∏ö', 'each', 'responsible']):
            return 'assignment'
        elif any(word in question_lower for word in ['‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ', 'project']):
            return 'project'
        elif any(word in question_lower for word in ['‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô', 'employee', '‡∏Å‡∏µ‡πà‡∏Ñ‡∏ô']):
            return 'employee'
        elif any(word in question_lower for word in ['‡∏á‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì', 'budget', '‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', 'salary']):
            return 'financial'
        else:
            return 'general'
    
    def _generate_context_aware_prompt(self, question: str, profile: CompanyProfile, question_type: str) -> str:
        """üìù ‡∏™‡∏£‡πâ‡∏≤‡∏á Context-Aware Prompt"""
        
        # Get base template
        template = self.prompt_templates.get(profile.prompt_template, self.prompt_templates['enterprise_thai'])
        
        # Fill in company-specific information
        filled_template = template.format(
            company_name=profile.name,
            question=question
        )
        
        # Add business logic hints for specific question types
        business_hints = self._get_business_logic_hints(question_type, profile)
        if business_hints:
            filled_template += f"\n\nüí° Business Logic Hints:\n{business_hints}"
        
        return filled_template
    
    def _get_business_logic_hints(self, question_type: str, profile: CompanyProfile) -> str:
        """üí° ‡∏î‡∏∂‡∏á Business Logic Hints ‡πÄ‡∏â‡∏û‡∏≤‡∏∞"""
        
        mappings = self.business_logic_mappings.get(profile.company_id, {})
        hints = []
        
        if question_type == 'assignment':
            hints.append("‚Ä¢ ‡πÉ‡∏ä‡πâ LEFT JOIN ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏£‡∏ß‡∏°‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ)")
            hints.append("‚Ä¢ ‡πÉ‡∏ä‡πâ COALESCE(p.name, '‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ') ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö NULL handling")
            hints.append("‚Ä¢ ‡πÉ‡∏ä‡πâ COALESCE(ep.role, '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó') ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö role")
        
        elif question_type == 'project' or question_type == 'tourism_project':
            if profile.business_type == 'tourism_hospitality':
                hints.append("‚Ä¢ ‡∏°‡∏≠‡∏á‡∏´‡∏≤‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß: ILIKE '%‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß%' OR ILIKE '%‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°%'")
                hints.append("‚Ä¢ ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏° hospitality: ‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°, TAT, ‡∏™‡∏ß‡∏ô‡∏û‡∏§‡∏Å‡∏©‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå")
            elif profile.business_type == 'global_operations':
                hints.append("‚Ä¢ ‡∏°‡∏≠‡∏á‡∏´‡∏≤‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ international: ILIKE '%International%' OR ILIKE '%Global%'")
                hints.append("‚Ä¢ ‡∏á‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì‡∏°‡∏±‡∏Å‡πÄ‡∏õ‡πá‡∏ô USD ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏™‡∏π‡∏á")
        
        elif question_type == 'financial':
            if profile.currency == 'USD':
                hints.append("‚Ä¢ ‡∏à‡∏±‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏á‡∏¥‡∏ô: TO_CHAR(budget, 'FM999,999,999') || ' USD'")
            else:
                hints.append("‚Ä¢ ‡∏à‡∏±‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏á‡∏¥‡∏ô: TO_CHAR(budget, 'FM999,999,999') || ' ‡∏ö‡∏≤‡∏ó'")
        
        # Add business logic mappings
        for concept, sql_condition in mappings.items():
            if concept in question_type or any(word in concept for word in question_type.split('_')):
                hints.append(f"‚Ä¢ {concept}: {sql_condition}")
        
        return '\n'.join(hints) if hints else ""
    
    def _extract_and_validate_sql(self, ai_response: str, profile: CompanyProfile, question_type: str) -> str:
        """üîß ‡πÅ‡∏¢‡∏Å SQL ‡πÅ‡∏•‡∏∞ validate"""
        
        # Clean response
        cleaned = ai_response.strip()
        
        # Extract SQL patterns
        sql_patterns = [
            r'```sql\s*(.*?)\s*```',
            r'```\s*(SELECT.*?;?)\s*```',
            r'(SELECT.*?;)',
        ]
        
        extracted_sql = None
        for pattern in sql_patterns:
            match = re.search(pattern, cleaned, re.DOTALL | re.IGNORECASE)
            if match:
                extracted_sql = match.group(1).strip()
                if extracted_sql.upper().startswith('SELECT'):
                    break
        
        if not extracted_sql:
            # Try line-by-line extraction
            lines = cleaned.split('\n')
            sql_lines = []
            
            for line in lines:
                line = line.strip()
                if line.upper().startswith('SELECT') or sql_lines:
                    sql_lines.append(line)
                    if line.endswith(';'):
                        break
            
            if sql_lines:
                extracted_sql = ' '.join(sql_lines)
        
        if not extracted_sql:
            raise ValueError("Could not extract SQL from AI response")
        
        # Clean up SQL
        extracted_sql = ' '.join(extracted_sql.split())  # Remove extra whitespace
        if not extracted_sql.endswith(';'):
            extracted_sql += ';'
        
        # Basic validation
        if not self._validate_basic_sql(extracted_sql):
            raise ValueError("Generated SQL failed basic validation")
        
        return extracted_sql
    
    def _validate_basic_sql(self, sql: str) -> bool:
        """‚úÖ Basic SQL validation"""
        sql_upper = sql.upper()
        
        # Must be SELECT
        if not sql_upper.startswith('SELECT'):
            return False
        
        # No dangerous operations
        dangerous = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'ALTER', 'CREATE', 'TRUNCATE']
        if any(keyword in sql_upper for keyword in dangerous):
            return False
        
        # Must have FROM
        if 'FROM' not in sql_upper:
            return False
        
        return True
    
    def _apply_type_safety_rules(self, sql: str, profile: CompanyProfile) -> str:
        """üõ°Ô∏è ‡πÉ‡∏ä‡πâ Type Safety Rules"""
        
        safe_sql = sql
        
        # Check for dangerous patterns
        for pattern in self.type_safety_rules['dangerous_patterns']:
            if re.search(pattern, safe_sql, re.IGNORECASE):
                logger.warning(f"Found dangerous pattern: {pattern}")
                # Apply fix based on pattern type
                if '‡πÑ‡∏°‡πà‡∏°‡∏µ' in pattern:
                    # Replace direct comparisons with proper COALESCE
                    safe_sql = re.sub(
                        r'WHERE\s+([^=]+)\s*=\s*\'‡πÑ‡∏°‡πà‡∏°‡∏µ[^\']*\'',
                        r'WHERE COALESCE(\1, \'‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•\') = \'‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•\'',
                        safe_sql,
                        flags=re.IGNORECASE
                    )
        
        # Ensure proper NULL handling in assignment queries
        if 'LEFT JOIN' in safe_sql.upper() and 'COALESCE' not in safe_sql.upper():
            logger.info("Adding COALESCE for NULL handling in LEFT JOIN query")
            # This is a basic fix - in production, you'd want more sophisticated logic
            safe_sql = safe_sql.replace('p.name', 'COALESCE(p.name, \'‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ\')')
        
        return safe_sql
    
    def _calculate_confidence(self, sql: str, question: str, profile: CompanyProfile) -> str:
        """üìä ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì confidence level"""
        
        confidence_score = 0.5  # Base score
        
        # SQL quality indicators
        sql_upper = sql.upper()
        
        if 'LEFT JOIN' in sql_upper and 'COALESCE' in sql_upper:
            confidence_score += 0.2  # Good assignment query structure
        
        if 'ORDER BY' in sql_upper and 'LIMIT' in sql_upper:
            confidence_score += 0.1  # Good query structure
        
        if 'GROUP BY' in sql_upper and any(agg in sql_upper for agg in ['COUNT', 'SUM', 'AVG']):
            confidence_score += 0.1  # Good aggregation
        
        # Business context matching
        question_lower = question.lower()
        if profile.business_type == 'tourism_hospitality':
            if any(keyword in question_lower for keyword in ['‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß', 'tourism', '‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°']):
                confidence_score += 0.1
        
        elif profile.business_type == 'global_operations':
            if any(keyword in question_lower for keyword in ['usd', 'international', 'global']):
                confidence_score += 0.1
        
        # Convert to category
        if confidence_score >= 0.8:
            return 'high'
        elif confidence_score >= 0.6:
            return 'medium'
        else:
            return 'low'
    
    def _generate_safe_fallback_sql(self, question: str, tenant_id: str) -> str:
        """üõ°Ô∏è ‡∏™‡∏£‡πâ‡∏≤‡∏á Safe Fallback SQL"""
        question_lower = question.lower()
        
        # Safe fallback based on question keywords
        if any(word in question_lower for word in ['‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô', 'employee', '‡∏Ñ‡∏ô']):
            return "SELECT name, position, department FROM employees ORDER BY hire_date DESC LIMIT 10;"
        elif any(word in question_lower for word in ['‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ', 'project', '‡∏á‡∏≤‡∏ô']):
            return "SELECT name, client, status FROM projects ORDER BY start_date DESC LIMIT 10;"
        elif any(word in question_lower for word in ['‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', 'salary']):
            return "SELECT name, position, salary FROM employees ORDER BY salary DESC LIMIT 10;"
        elif any(word in question_lower for word in ['‡∏á‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì', 'budget']):
            return "SELECT name, client, budget FROM projects ORDER BY budget DESC LIMIT 10;"
        else:
            return "SELECT 'Universal Prompt System: Safe fallback query' as message LIMIT 1;"
    
    def get_statistics(self) -> Dict[str, Any]:
        """üìä ‡∏î‡∏∂‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô"""
        
        success_rate = 0
        if self.generation_stats['total_queries'] > 0:
            success_rate = (self.generation_stats['successful_generations'] / 
                          self.generation_stats['total_queries']) * 100
        
        return {
            'total_queries_processed': self.generation_stats['total_queries'],
            'successful_generations': self.generation_stats['successful_generations'],
            'success_rate_percentage': round(success_rate, 2),
            'template_usage_stats': self.generation_stats['template_usage'],
            'tenant_usage_stats': self.generation_stats['tenant_usage'],
            'companies_supported': len(self.company_profiles),
            'templates_available': len(self.prompt_templates),
            'last_updated': datetime.now().isoformat()
        }
    
    def get_company_profile(self, tenant_id: str) -> Optional[CompanyProfile]:
        """üè¢ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Company Profile"""
        return self.company_profiles.get(tenant_id)
    
    def list_supported_companies(self) -> List[Dict[str, Any]]:
        """üìã ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ companies ‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö"""
        companies = []
        for company_id, profile in self.company_profiles.items():
            companies.append({
                'company_id': profile.company_id,
                'name': profile.name,
                'business_type': profile.business_type,
                'language': profile.language,
                'currency': profile.currency,
                'prompt_template': profile.prompt_template,
                'entities_count': len(profile.business_entities)
            })
        return companies
    
    async def test_universal_prompt_generation(self, test_questions: List[Tuple[str, str]]) -> Dict[str, Any]:
        """üß™ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Universal Prompt Generation"""
        
        test_results = []
        
        for tenant_id, question in test_questions:
            try:
                start_time = datetime.now()
                
                # Mock agent for testing
                class MockAgent:
                    def __init__(self):
                        from .tenant_config import TenantConfig
                        self.tenant_configs = {
                            'company-a': TenantConfig('company-a', 'SiamTech Bangkok HQ', 'localhost', 5432, 'db', 'user', 'pass', 'llama3.1:8b', 'th', 'enterprise', []),
                            'company-b': TenantConfig('company-b', 'SiamTech Chiang Mai', 'localhost', 5432, 'db', 'user', 'pass', 'llama3.1:8b', 'th', 'tourism', []),
                            'company-c': TenantConfig('company-c', 'SiamTech International', 'localhost', 5432, 'db', 'user', 'pass', 'llama3.1:8b', 'en', 'global', [])
                        }
                        self.ai_service = MockAIService()
                
                class MockAIService:
                    async def call_ollama_api(self, tenant_config, prompt, context_data="", temperature=0.1):
                        # Mock AI response with SQL
                        if 'assignment' in prompt.lower() or '‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô' in prompt.lower():
                            return """SELECT 
    e.name as employee_name,
    e.position,
    COALESCE(p.name, '‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ') as project_name,
    COALESCE(ep.role, '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó') as project_role
FROM employees e
LEFT JOIN employee_projects ep ON e.id = ep.employee_id
LEFT JOIN projects p ON ep.project_id = p.id
ORDER BY e.name
LIMIT 20;"""
                        
                        elif 'project' in prompt.lower() or '‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ' in prompt.lower():
                            return """SELECT 
    name as project_name,
    client,
    budget,
    status
FROM projects 
ORDER BY budget DESC 
LIMIT 10;"""
                        
                        else:
                            return "SELECT 'Test query' as result LIMIT 1;"
                
                mock_agent = MockAgent()
                
                sql_query, metadata = await self.generate_sql_with_universal_prompt(
                    question, tenant_id, mock_agent
                )
                
                processing_time = (datetime.now() - start_time).total_seconds()
                
                test_results.append({
                    'tenant_id': tenant_id,
                    'question': question,
                    'success': True,
                    'sql_generated': sql_query,
                    'method': metadata['method'],
                    'template_used': metadata.get('template_used'),
                    'confidence': metadata.get('confidence'),
                    'processing_time_ms': round(processing_time * 1000, 2)
                })
                
            except Exception as e:
                test_results.append({
                    'tenant_id': tenant_id,
                    'question': question,
                    'success': False,
                    'error': str(e),
                    'method': 'failed'
                })
        
        # Calculate overall test statistics
        total_tests = len(test_results)
        successful_tests = len([r for r in test_results if r['success']])
        success_rate = (successful_tests / total_tests * 100) if total_tests > 0 else 0
        
        return {
            'test_summary': {
                'total_tests': total_tests,
                'successful_tests': successful_tests,
                'failed_tests': total_tests - successful_tests,
                'success_rate_percentage': round(success_rate, 2)
            },
            'test_results': test_results,
            'system_status': 'operational' if success_rate >= 80 else 'needs_attention'
        }


# üß™ Test Function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Universal Prompt System
async def test_complete_universal_prompt_system():
    """üß™ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Universal Prompt System ‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô"""
    
    print("üß™ Testing Complete Universal Prompt System")
    print("=" * 70)
    
    # Initialize system
    generator = UniversalPromptGenerator()
    
    # Test 1: Company Profiles
    print("\n1Ô∏è‚É£ Testing Company Profiles:")
    companies = generator.list_supported_companies()
    for company in companies:
        print(f"   ‚úÖ {company['name']} ({company['business_type']}) - {company['language']}")
    
    # Test 2: Question Type Analysis
    print("\n2Ô∏è‚É£ Testing Question Type Analysis:")
    test_questions = [
        ("company-a", "‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô siamtech ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô‡∏£‡∏±‡∏ö‡∏ú‡∏¥‡∏î‡∏ä‡∏≠‡∏ö‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏≠‡∏∞‡πÑ‡∏£‡∏ö‡πâ‡∏≤‡∏á"),
        ("company-b", "‡∏°‡∏µ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß‡∏≠‡∏∞‡πÑ‡∏£‡∏ö‡πâ‡∏≤‡∏á"), 
        ("company-c", "Which projects have highest USD budget")
    ]
    
    for tenant_id, question in test_questions:
        profile = generator.get_company_profile(tenant_id)
        question_type = generator._analyze_question_type(question, profile)
        print(f"   üéØ {tenant_id}: '{question[:40]}...' ‚Üí {question_type}")
    
    # Test 3: Prompt Generation
    print("\n3Ô∏è‚É£ Testing Universal Prompt Generation:")
    test_results = await generator.test_universal_prompt_generation(test_questions)
    
    print(f"   üìä Success Rate: {test_results['test_summary']['success_rate_percentage']}%")
    print(f"   ‚úÖ Successful: {test_results['test_summary']['successful_tests']}")
    print(f"   ‚ùå Failed: {test_results['test_summary']['failed_tests']}")
    
    for result in test_results['test_results']:
        status = "‚úÖ" if result['success'] else "‚ùå"
        print(f"   {status} {result['tenant_id']}: {result.get('method', 'failed')}")
    
    # Test 4: Statistics
    print("\n4Ô∏è‚É£ System Statistics:")
    stats = generator.get_statistics()
    print(f"   üìà Total Queries: {stats['total_queries_processed']}")
    print(f"   ‚úÖ Success Rate: {stats['success_rate_percentage']}%")
    print(f"   üè¢ Companies: {stats['companies_supported']}")
    print(f"   üìù Templates: {stats['templates_available']}")
    
    # Overall status
    overall_success = test_results['test_summary']['success_rate_percentage'] >= 80
    print(f"\nüéØ Overall Status: {'‚úÖ READY FOR PRODUCTION' if overall_success else '‚ö†Ô∏è NEEDS IMPROVEMENT'}")
    
    return overall_success

# üöÄ Integration Helper Function
def create_universal_prompt_integration_guide():
    """üìö ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠‡∏Å‡∏≤‡∏£ Integration"""
    
    guide = """
üöÄ Universal Prompt System Integration Guide
==========================================

üìÅ Files to Update:
------------------
1. refactored_modules/universal_prompt_system.py (‚úÖ Ready)
2. refactored_modules/enhanced_postgres_agent_refactored.py (‚úÖ Updated)

üîß Integration Steps:
-------------------
1. Replace old universal_prompt_system.py with new version
2. Restart the container/service
3. Test with curl commands
4. Verify sql_generation_method = "universal_prompt_system"

üß™ Test Commands:
----------------
# Company A (Enterprise)
curl -X POST http://localhost:5000/enhanced-rag-query \
  -H "Content-Type: application/json" \
  -H "X-Tenant-ID: company-a" \
  -d '{"query": "‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô‡∏£‡∏±‡∏ö‡∏ú‡∏¥‡∏î‡∏ä‡∏≠‡∏ö‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏≠‡∏∞‡πÑ‡∏£‡∏ö‡πâ‡∏≤‡∏á"}'

# Company B (Tourism) 
curl -X POST http://localhost:5000/enhanced-rag-query \
  -H "Content-Type: application/json" \
  -H "X-Tenant-ID: company-b" \
  -d '{"query": "‡∏°‡∏µ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏ó‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏ß‡∏≠‡∏∞‡πÑ‡∏£‡∏ö‡πâ‡∏≤‡∏á"}'

# Company C (International)
curl -X POST http://localhost:5000/enhanced-rag-query \
  -H "Content-Type: application/json" \
  -H "X-Tenant-ID: company-c" \
  -d '{"query": "Which projects have highest USD budget"}'

# Check Universal Prompt Status
curl http://localhost:5000/universal-prompt-status

‚úÖ Expected Results:
------------------
- sql_generation_method: "universal_prompt_system"
- data_source_used: "universal_prompt_[model]"
- fallback_mode: false
- confidence_level: "high" or "medium"
- enhancement_version: "3.0_universal_prompt"

üéØ Success Criteria:
------------------
- All 3 companies use Universal Prompt System
- No more Few-Shot Learning fallbacks  
- SQL queries generated successfully
- Business-appropriate responses
- No AttributeError exceptions

‚ö†Ô∏è Troubleshooting:
------------------
- If AttributeError: Check method names in universal_prompt_system.py
- If fallback_mode: true: Check Intent Classification
- If SQL errors: Check Type Safety Rules
- If wrong responses: Check Prompt Templates
"""
    
    return guide

if __name__ == "__main__":
    print("üéØ Universal Prompt System - Complete Implementation")
    print("üî• Ready for Multi-Tenant Production Deployment")
    
    # Print integration guide
    print(create_universal_prompt_integration_guide())
    
    # Run tests
    import asyncio
    asyncio.run(test_complete_universal_prompt_system())
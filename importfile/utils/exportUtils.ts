import { Schema, Company } from '../types/schema';

export class ExportUtils {
  static exportToJSON(schemas: Schema[], company: Company): void {
    const exportData = {
      metadata: {
        company,
        exportDate: new Date().toISOString(),
        version: '1.0.0',
        tool: 'Schema Management System'
      },
      schemas: schemas.map(schema => ({
        name: schema.name,
        type: schema.type,
        description: schema.description,
        tables: schema.tables,
        tableCount: schema.tables.length,
        createdAt: schema.createdAt
      }))
    };

    this.downloadFile(
      JSON.stringify(exportData, null, 2),
      `schema-export-${company.code}-${this.formatDate(new Date())}.json`,
      'application/json'
    );
  }

  static exportToSQL(schemas: Schema[], company: Company): void {
    let sqlContent = `-- Schema Export for ${company.name}\n`;
    sqlContent += `-- Database: ${company.dbName}\n`;
    sqlContent += `-- Export Date: ${new Date().toISOString()}\n`;
    sqlContent += `-- Generated by Schema Management System\n\n`;

    schemas.forEach(schema => {
      if (schema.type === 'custom') {
        sqlContent += `-- Create Schema: ${schema.name}\n`;
        sqlContent += `CREATE SCHEMA IF NOT EXISTS "${schema.name}";\n`;
        
        if (schema.description) {
          sqlContent += `COMMENT ON SCHEMA "${schema.name}" IS '${schema.description}';\n`;
        }
        
        sqlContent += '\n';
      }

      schema.tables.forEach(tableName => {
        sqlContent += `-- TODO: Add CREATE TABLE statement for ${schema.name}.${tableName}\n`;
        sqlContent += `-- Use Schema Management System to generate the actual SQL\n\n`;
      });
    });

    this.downloadFile(
      sqlContent,
      `schema-export-${company.code}-${this.formatDate(new Date())}.sql`,
      'text/sql'
    );
  }

  private static downloadFile(content: string, filename: string, mimeType: string): void {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    link.href = url;
    link.download = filename;
    
    // เพิ่ม try-catch สำหรับ browser compatibility
    try {
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error('Download error:', error);
      // Fallback สำหรับ browser เก่า
      window.open(url, '_blank');
    }
    
    // Clean up
    setTimeout(() => {
      URL.revokeObjectURL(url);
    }, 100);
  }

  private static formatDate(date: Date): string {
    return date.toISOString().split('T')[0];
  }

  // เพิ่ม method สำหรับ export CSV format
  static exportToCSV(schemas: Schema[], company: Company): void {
    let csvContent = 'Schema Name,Type,Description,Table Count,Tables,Created At\n';
    
    schemas.forEach(schema => {
      const tablesStr = schema.tables.join(';'); // ใช้ semicolon แยก tables
      const row = [
        schema.name,
        schema.type,
        schema.description || '',
        schema.tables.length.toString(),
        tablesStr,
        schema.createdAt
      ].map(field => `"${field.replace(/"/g, '""')}"`).join(','); // Escape quotes ใน CSV
      
      csvContent += row + '\n';
    });

    this.downloadFile(
      csvContent,
      `schema-export-${company.code}-${this.formatDate(new Date())}.csv`,
      'text/csv'
    );
  }
}